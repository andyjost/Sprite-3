// No include guards.

#ifdef SPRITE_CLASS_CONTEXT
#define SPRITE_DECL_ONLY 0
#else
#define SPRITE_CLASS_CONTEXT
#define SPRITE_DECL_ONLY 1
#endif

#ifndef SPRITE_OP_INT_FLAG_CHECK
#define SPRITE_OP_INT_FLAG_CHECK SPRITE_NO_FLAG_CHECK
#endif

#ifndef SPRITE_OP_FP_FLAG_CHECK
#define SPRITE_OP_FP_FLAG_CHECK SPRITE_NO_FLAG_CHECK
#endif

#define SPRITE_INVOKE(f, x) f x

#define SPRITE_NO_FLAG_CHECK(name)

#define SPRITE_ALLOW_NSW_NUW_FLAGS(name)           \
    SPRITE_ALLOW_FLAGS(rhs, name                   \
      , operator_flags::NUW | operator_flags::NSW  \
      )                                            \
  /**/

#define SPRITE_ALLOW_SIGNED_FLAG(name)                    \
    SPRITE_ALLOW_FLAGS(rhs, name, operator_flags::SIGNED) \
  /**/

#define SPRITE_ALLOW_DIV_FLAGS(name)                      \
    SPRITE_ALLOW_FLAGS(rhs, name                          \
      , operator_flags::SIGNED | operator_flags::UNSIGNED \
          | operator_flags::EXACT                         \
      )                                                   \
   check_for_exactly_one_signed_flag(rhs.flags(), name);  \
  /**/

#define SPRITE_ALLOW_SHR_FLAGS(name)                         \
    SPRITE_ALLOW_FLAGS(rhs, name                             \
      , operator_flags::ARITHMETIC | operator_flags::LOGICAL \
          | operator_flags::EXACT                            \
      )                                                      \
   check_for_exactly_one_arithmetic_flag(rhs.flags(), name); \
  /**/

#define SPRITE_REQUIRE_SIGNED_UNSIGNED_FLAG(name)         \
    SPRITE_ALLOW_FLAGS(rhs, name                          \
      , operator_flags::SIGNED | operator_flags::UNSIGNED \
      )                                                   \
   check_for_exactly_one_signed_flag(rhs.flags(), name);  \
  /**/

#ifdef SPRITE_INPLACE_OP
template<typename Rhs>
typename std::enable_if<is_raw_initializer<Rhs>::value, SPRITE_LHS_TYPE &>::type
SPRITE_CLASS_CONTEXT operator SPRITE_INPLACE_OP(Rhs const & rhs)
#if SPRITE_DECL_ONLY
;
#else
{
  auto const rhs_ = get_constant(get_type(*this), rhs);
  (*this) SPRITE_INPLACE_OP rhs_;
  return *this;
}
#endif

template<typename Rhs>
typename std::enable_if<is_constarg<Rhs>::value, SPRITE_LHS_TYPE &>::type
SPRITE_CLASS_CONTEXT operator SPRITE_INPLACE_OP(Rhs const & rhs)
#if SPRITE_DECL_ONLY
;
#else
{
  (*this) SPRITE_INPLACE_OP aux::operator_flags() (rhs);
  return *this;
}
#endif

#ifndef SPRITE_OP_CUSTOM_BODY
template<typename Rhs>
typename std::enable_if<is_constarg<Rhs>::value, SPRITE_LHS_TYPE &>::type
SPRITE_CLASS_CONTEXT operator SPRITE_INPLACE_OP (aux::arg_with_flags<Rhs> const & rhs)
#if SPRITE_DECL_ONLY
;
#else
{
  type const ty = coerce(get_type(*this), get_type(rhs));
  auto const lhs_ = get_value(ty, *this);
  auto const rhs_ = get_value(ty, rhs);
  aux::operator_flags const & flags = rhs.flags();
  (void) flags; // may be unused
  if(ty->isIntegerTy())
  {
    SPRITE_INVOKE(SPRITE_OP_INT_FLAG_CHECK, ("integer " SPRITE_OP_NAME))
    *this = SPRITE_LHS_TYPE(SPRITE_APICALL(
        SPRITE_OP_INT_IMPL(lhs_.ptr(), rhs_.ptr(), flags)
      ));
    return *this;
  }
#ifdef SPRITE_OP_FP_IMPL
  if(ty->isFloatingPointTy())
  {
    SPRITE_INVOKE(SPRITE_OP_FP_FLAG_CHECK, ("floating-point " SPRITE_OP_NAME))
    *this = SPRITE_LHS_TYPE(SPRITE_APICALL(
        SPRITE_OP_FP_IMPL(lhs_.ptr(), rhs_.ptr(), flags)
      ));
    return *this;
  }
#endif
  throw type_error(
      "Expected integer "
#ifdef SPRITE_OP_FP_IMPL
      "or floating-point "
#endif
      "arguments for " SPRITE_OP_NAME "."
    );
}
#endif
#endif
#endif

#ifdef SPRITE_OP
template<typename Lhs, typename Rhs>
typename op_result_type<Lhs,Rhs>::type
operator SPRITE_OP(Lhs const & lhs, aux::arg_with_flags<Rhs> const & rhs)
{
  using result_type = typename op_result_type<Lhs,Rhs>::type;
  result_type lhs_ = get_value(lhs);
  lhs_ SPRITE_INPLACE_OP rhs;
  return lhs_;
}

template<typename Lhs, typename Rhs>
inline typename std::enable_if<
    is_valuearg<Lhs>::value || is_valuearg<Rhs>()
  , typename op_result_type<Lhs,Rhs>::type
  >::type
operator SPRITE_OP(Lhs const & lhs, Rhs const & rhs)
  { return lhs SPRITE_OP aux::operator_flags() (rhs); }
#endif

#undef SPRITE_ALLOW_DIV_FLAGS
#undef SPRITE_ALLOW_NSW_NUW_FLAGS
#undef SPRITE_ALLOW_SIGNED_FLAG
#undef SPRITE_CLASS_CONTEXT
#undef SPRITE_DECL_ONLY
#undef SPRITE_INVOKE
#undef SPRITE_INPLACE_OP
#undef SPRITE_LHS_TYPE
#undef SPRITE_OP
#undef SPRITE_OP_CUSTOM_BODY
#undef SPRITE_OP_FP_FLAG_CHECK
#undef SPRITE_OP_FP_IMPL
#undef SPRITE_OP_INT_FLAG_CHECK
#undef SPRITE_OP_INT_IMPL
#undef SPRITE_OP_NAME
