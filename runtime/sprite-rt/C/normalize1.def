// Normalizes a unary node.
//
// Variable root must be pre-defined.  The successor must normalize to a data
// term (i.e., one with exactly one constructor), or TAG must be defined so that
// the tag is never greater than zero.

// The NORMALIZE macro may be defined to control how to perform normalization.
#ifndef NORMALIZE
#define NORMALIZE(arg) arg->vptr->H(arg)
#endif

// The SELECT macro selects which successor to normalize.
#ifndef SELECT
#define SELECT SUCC_0
#endif


// The TAG macro may be defined to control how the tag of the inductive node is
// obtained.  When the argument being normalized is a type with only one
// constructor (such as a built-in data type), then the call to min is not needed.
#ifndef TAG
#define TAG(arg) (arg->tag < 0 ? arg->tag : 0)
#endif

// The action to take when a free variable is encountered.  By default, do
// nothing (i.e., fall through to the constructor case.
#ifndef WHEN_FREE
#define WHEN_FREE(arg)
#endif

  static void * table[] =
      { &&t_fail, &&t_free, &&t_fwd, &&t_choice, &&t_oper, &&t_ctor};
  node * arg = SELECT(root);
  node * lhs_choice, * rhs_choice;
  goto* (&table[TAGOFFSET])[TAG(arg)];
t_fail:
  return CyPrelude_failed(root);
t_fwd:
  arg = reinterpret_cast<node *>(arg->slot0);
  goto* (&table[TAGOFFSET])[TAG(arg)];
t_choice:
  NODE_ALLOC(lhs_choice, t_choice);
  NODE_ALLOC(rhs_choice, t_choice);
  lhs_choice->vptr = root->vptr;
  lhs_choice->tag = root->tag;
  lhs_choice->slot0 = arg->slot0;
  lhs_choice->slot1 = 0;
  rhs_choice->vptr = root->vptr;
  rhs_choice->tag = root->tag;
  rhs_choice->slot0 = arg->slot1;
  rhs_choice->slot1 = 0;
  root->vptr = &CyVt_Choice;
  root->tag = CHOICE;
  root->aux = arg->aux; // copy choice id
  root->slot0 = lhs_choice;
  root->slot1 = rhs_choice;
  return;
t_oper:
  NORMALIZE(arg);
  goto* (&table[TAGOFFSET])[TAG(arg)];
t_free:
  WHEN_FREE(arg);
t_ctor:
#undef NORMALIZE
#undef SELECT
#undef TAG
#undef WHEN_FREE

