'''
cytest - A module to compare Curry output.
'''

from __future__ import print_function
import os
import re
import shutil
import subprocess
import sys
import unittest

# OK to change the next value.
VERBOSE = True

if VERBOSE:
  def log(*args):
      sys.stdout.write('[INFO]: ')
      print(*args)
else:
  def log(*args): pass

def top_help(exitcode, stream):
  stream.write(
      '''
      USAGE: %s [clean|compare|help|validate] filenames...

          clean
              Clean up any changes to the .curry source files caused by 'mkgold'.
          compare
              Compare the results produced by Sprite with the results produced
              the oracle for one or more .curry files.
          help
              Display this help message.
          mkgold
              Generate golden results by running the oracle and appending its result
              to the .curry file.
          validate
              Validate the comparisons of a previous call to 'compare'.  The
              results are stored in files ending with .results.
      ''' % sys.argv[0]
    )
  os._exit(exitcode)

# Note: warnings.warn does not interoperate well with unittest.  Moreover,
# shell directs cannot redirect stdout and stderr to a file while printing a
# copy of stderr to tty.  Prepend $$ to identify error messages.
def warn(msg):
  sys.stderr.write('\n')
  sys.stderr.write('$$ ')
  sys.stderr.write(msg.replace('\n', '\n$$ '))
  sys.stderr.write('\n')

def syscall(progname, args=''):
  '''
  Calls a system function and returns the contents written to stdout, split on
  newlines.  If the process writies anything to stderr, issues a warning.
  '''
  cmd = '%s %s' % (progname, args)
  log('Running command:', cmd)
  process = subprocess.Popen(
      cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True
    )
  (out,err) = process.communicate()

  # Special case for PAKCS.  If there is no value, PAKCSC exits with status 2.
  if progname == 'pakcs' and process.returncode == 2:
    return out

  if err:
    args = (
        sys.argv[0]
      , os.path.basename(progname)
      , err.strip().replace('\n', '\n        ')
      )
    warn('%s: %s generates error output:\n\n        %s' % args)
  if process.returncode != 0:
    warn(
        '%s: %s exited with status %s'
            % (sys.argv[0], os.path.basename(progname), process.returncode)
      )
    os._exit(1)
  return out

def extractAnswers(string, do_sort=True, kics_handling=False):
  lines = string.split('\n')
  if kics_handling:
    i = 0
    n = len(lines)
    while i<n and not lines[i].startswith('Evaluating expression: main'):
      i += 1
    lines = lines[i+1:]
  answer = [line for line in lines if line]
  return sorted(answer) if do_sort else answer

match_answer = re.compile('-->\s+(.*)')
banner = 'CORRECT ANSWER BELOW GENERATED BY cytest.py'
match_banner = re.compile(banner)

def getOracleAnswers(filename):
  if not any(map(match_banner.search, open(filename, 'r').readlines())):
    if open(filename, 'r').readline().startswith('-- KICS2 --'):
      oracle,opt_q,opt_h = 'kics2','',True
    else:
      oracle,opt_q,opt_h = 'pakcs','-q',False

    oracle_answer = extractAnswers(
        syscall(oracle, '%s :l %s :eval main :q' % (opt_q, filename))
      , kics_handling=opt_h
      )
    with open(filename, 'a') as cyfile:
      cyfile.write('\n------ %s using %s ------\n' % (banner, oracle))
      cyfile.write('\n'.join([ '--> ' + line for line in oracle_answer ]))
      cyfile.write('\n')
  else:
    oracle_answer = [
        match.group(1)
            for match in map(match_answer.match, open(filename, 'r').readlines())
            if match
      ]
  return oracle_answer

def getAnswers(filename):
  log('Processing file:', filename)
  oracle_answer = getOracleAnswers(filename)
  
  # Get the Sprite answer.
  head,tail = os.path.splitext(filename)
  if tail != '' and tail != '.curry':
    warn('%s: unexpected file extension: %s' % (sys.argv[0], tail))

  exe = os.path.abspath(head + '.exe')
  # syscall('scc', '-o %s %s' % (exe, filename))
  sprite_answer = extractAnswers(syscall(exe))
  log('Oracle answer: ', oracle_answer)
  log('Sprite answer:', sprite_answer)

  return oracle_answer, sprite_answer

def equalAnswers(tc, oracle, sprite):
  tc.assertEqual(
      len(oracle), len(sprite)
    , msg='len(oracle) != len(sprite)'
    )
  for p,s in zip(oracle, sprite):
    tc.assertTrue(
        # Tolerate extra parens surrounding.
        p == s or ('(%s)' % p) == s
      , msg='Oracle=%s  Sprite=%s' % (p, s) 
      )

def runTestSuite(tc):
  suite = unittest.TestLoader().loadTestsFromTestCase(tc)
  return unittest.TextTestRunner(stream=sys.stdout, verbosity=2).run(suite)

def top_clean():
  for filename in sys.argv[2:]:
    filename_copy = filename + '.copy'
    with open(filename_copy, 'w') as cp:
      for line in open(filename, 'r').readlines():
        if match_banner.search(line):
          break;
        cp.write(line)
    shutil.move(filename_copy, filename)

def top_mkgold():
  for filename in sys.argv[2:]:
    getOracleAnswers(filename)

def top_compare():
  class CompareTC(unittest.TestCase): pass
  for filename in sys.argv[2:]:
    base = os.path.splitext(os.path.basename(filename))[0]
    def test(self): equalAnswers(self, *getAnswers(filename))
    setattr(CompareTC, 'test_' + base, test)
  rv = runTestSuite(CompareTC)
  # The compare step succeeds as long as the tests were run (regardless of
  # whether or not they passed).
  sys.exit(0 if rv.testsRun == len(sys.argv[2:]) else 1)

def top_validate():
  class ValidateTC(unittest.TestCase): pass
  for filename in sys.argv[2:]:
    base = os.path.splitext(os.path.basename(filename))[0]
    def test(self):
      text = open(filename, 'r').readlines()[-1].strip()
      self.assertEquals(text, 'OK')
    setattr(ValidateTC, 'test_' + base, test)
  rv = runTestSuite(ValidateTC)
  sys.exit(0 if rv.wasSuccessful() else 1)

if __name__ == '__main__':
  command = sys.argv[1]
  if command == 'clean':
    top_clean()
  elif command == 'compare':
    top_compare()
  elif command == 'mkgold':
    top_mkgold()
  elif command == 'help':
    top_help(0, sys.stdout)
  elif command == 'validate':
    top_validate()
  else:
    sys.stderr.write('Invalid command: ' + command)
    top_help(1, sys.stderr)
